<!doctype html>
<meta charset="utf-8" />
<title>Maze Game</title>

<style>
  html,
  body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: #000000;
  }
  #swipeArea {
    position: fixed;
    inset: 0;
    z-index: 10;
    touch-action: none; /* stop browser gestures on mobile */
  }
  #timer, #lvlctr,
  #outputWrap {
    position: fixed;
    z-index: 20; /* above swipe area if you want text clickable/visible */
    left: 8px;
    color: #0f0;
    font:
      16px system-ui,
      sans-serif;
  }
  #timer {
    top: 24px;
  }
  #lvlctr {
    top: 8px;
  }
  #outputWrap {
    top: 32px;
  }
  canvas {
    display: block;
  }
</style>

<body>
  <canvas id="c"></canvas>
  <div id="swipeArea"></div>
  <div id="lvlctr">Level</div>
  <div id="timer">timer</div>
  <div id="outputWrap"></div>
  <div class="hidden">
    <img
      id="source"
      src="https://raw.githubusercontent.com/SuperIronDragon/SuperIronDragon/refs/heads/main/scotty_1_20x20.bmp"
      width="20"
      height="20"
    />
  </div>
  <div class="hidden">
    <img
      id="treat"
      src="https://raw.githubusercontent.com/SuperIronDragon/SuperIronDragon/refs/heads/main/dogtreat.bmp"
      width="17"
      height="17"
    />
  </div>
</body>

<script type = "module">
    
    import {startMusic} from "./music.js";
    startMusic();
    
  /* ================= CANVAS SETUP ================= */

  const c = document.getElementById("c");
  const ctx = c.getContext("2d");
  const swipeArea = document.getElementById("swipeArea");
  const timer = document.getElementById("timer");
  const lvlctr = document.getElementById("lvlctr");

  // timer
  let t = 0;
  let lastTime = 0;
  setInterval(() => {
    t++;
    timer.textContent = ((t - lastTime) / 10).toFixed(1);
  }, 100);

  // swipe detection
  let sx = 0,
    sy = 0,
    ex = 0,
    ey = 0,
    down = false;
  swipeArea.addEventListener("pointerdown", (e) => {
    down = true;
    sx = ex = e.clientX;
    sy = ey = e.clientY;
    swipeArea.setPointerCapture(e.pointerId); // FIX: keeps getting move/up
  });

  swipeArea.addEventListener("pointermove", (e) => {
    if (!down) return;
    ex = e.clientX;
    ey = e.clientY;
  });

  swipeArea.addEventListener("pointerup", (e) => {
    if (!down) return;
    down = false;

    // FIX: use pointerup coordinates (in case no move fired at the end)
    ex = e.clientX;
    ey = e.clientY;

    const dx = ex - sx,
      dy = ey - sy,
      m = 40;

    let dir = null;

    if (Math.abs(dx) > Math.abs(dy)) {
      if (Math.abs(dx) > m) dir = dx > 0 ? "ArrowRight" : "ArrowLeft";
    } else {
      if (Math.abs(dy) > m) dir = dy > 0 ? "ArrowDown" : "ArrowUp";
    }

    if (dir) {
      move(dir);
      dir = null;
    }
  });

  function move(dir) {
    if (dir === "ArrowLeft" && Xpos > 0 && VmazeArray[Xpos][Ypos] === 0) Xpos--;

    if (
      dir === "ArrowRight" &&
      Xpos < n - 1 &&
      VmazeArray[Xpos + 1][Ypos] === 0
    )
      Xpos++;

    if (dir === "ArrowUp" && Ypos > 0 && HmazeArray[Xpos][Ypos] === 0) Ypos--;

    if (dir === "ArrowDown" && Ypos < n - 1 && HmazeArray[Xpos][Ypos + 1] === 0)
      Ypos++;

    if (Xpos === n - 1 && Ypos === n - 1) playerWinEvent();
  }

  swipeArea.addEventListener("pointercancel", () => {
    down = false;
  });

  function resize() {
    const dpr = devicePixelRatio || 1;
    c.style.width = innerWidth + "px";
    c.style.height = innerHeight + "px";
    c.width = innerWidth * dpr;
    c.height = innerHeight * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize);
  resize();

  /* ================= GAME STATE ================= */

  let n = 8;
  let numLevels = 5;
  let startN = n;
  let Xpos = 0,
    Ypos = 0;
  let imgX = 0;
  let imgY = 0;

  lastTime = t;

  let HmazeArray = [];
  let VmazeArray = [];

  let W = innerWidth;
  let H = innerHeight;
  let vOff = (W - Math.min(W, H)) / 2;
  let s = 0;

  // 1.1: 3x3
  // 0.1: 1x1
  let visibility = 1.1;

  /* ================= MAZE GENERATION ================= */
  /* Randomized DFS (perfect maze) */

  function createMaze() {
    Xpos = 0;
    Ypos = 0;

    // walls = 1 (present)
    HmazeArray = Array.from({ length: n }, () => Array(n + 1).fill(1));
    VmazeArray = Array.from({ length: n + 1 }, () => Array(n).fill(1));

    const visited = Array.from({ length: n }, () => Array(n).fill(false));
    const stack = [[0, 0]];
    visited[0][0] = true;

    while (stack.length) {
      const [x, y] = stack[stack.length - 1];

      const neighbors = [];
      if (x > 0 && !visited[x - 1][y]) neighbors.push([x - 1, y, 0]);
      if (x < n - 1 && !visited[x + 1][y]) neighbors.push([x + 1, y, 1]);
      if (y > 0 && !visited[x][y - 1]) neighbors.push([x, y - 1, 2]);
      if (y < n - 1 && !visited[x][y + 1]) neighbors.push([x, y + 1, 3]);

      if (neighbors.length === 0) {
        stack.pop();
        continue;
      }

      const [nx, ny, dir] =
        neighbors[Math.floor(Math.random() * neighbors.length)];

      // remove wall
      if (dir === 0) VmazeArray[x][y] = 0; // west
      if (dir === 1) VmazeArray[x + 1][y] = 0; // east
      if (dir === 2) HmazeArray[x][y] = 0; // north
      if (dir === 3) HmazeArray[x][y + 1] = 0; // south

      visited[nx][ny] = true;
      stack.push([nx, ny]);
    }
    flashLights();
  }

  /* ================= INPUT ================= */

  onkeydown = (e) => {
    if (e.key === "ArrowLeft" && Xpos > 0 && VmazeArray[Xpos][Ypos] === 0)
      Xpos--;
    if (
      e.key === "ArrowRight" &&
      Xpos < n - 1 &&
      VmazeArray[Xpos + 1][Ypos] === 0
    )
      Xpos++;
    if (e.key === "ArrowUp" && Ypos > 0 && HmazeArray[Xpos][Ypos] === 0) Ypos--;
    if (
      e.key === "ArrowDown" &&
      Ypos < n - 1 &&
      HmazeArray[Xpos][Ypos + 1] === 0
    )
      Ypos++;

    if (Xpos === n - 1 && Ypos === n - 1) playerWinEvent();
  };

  function playerWinEvent() {
    if (n < startN + numLevels-1) {
        t=0;
      n++;
      createMaze();
    } else {
      alert("You win!");
    }
  }

  /* ================= RENDERING ================= */

  function drawMaze() {
    lvlctr.textContent = "Level " + (n - startN + 1);

    W = innerWidth;
    H = innerHeight;
    vOff = (W - Math.min(W, H)) / 2;
    s = Math.min(W, H) / n;

    ctx.clearRect(0, 0, c.width, c.height);

    ctx.fillStyle = "#111";
    ctx.fillRect(vOff, 0, s * n, s * n);

    ctx.strokeStyle = "#666";
    ctx.lineWidth = 4;
    ctx.beginPath();

    for (let x = 0; x < n; x++)
      for (let y = 0; y < n + 1; y++)
        if (HmazeArray[x][y]) {
          ctx.moveTo(vOff + x * s, y * s);
          ctx.lineTo(vOff + (x + 1) * s, y * s);
        }

    for (let x = 0; x < n + 1; x++)
      for (let y = 0; y < n; y++)
        if (VmazeArray[x][y]) {
          ctx.moveTo(vOff + x * s, y * s);
          ctx.lineTo(vOff + x * s, (y + 1) * s);
        }

    ctx.stroke();

    // player
    drawHalo();

    drawPlayer();
    

    // treat
    ctx.fillStyle = "#0f0";
    const image2 = document.getElementById("treat");
    ctx.drawImage(
      image2,
      vOff + (n - 1) * s + s * 0.3,
      (n - 1) * s + s * 0.3,
      s * 0.4,
      s * 0.4,
    );
    /*ctx.fillRect(
    vOff + Xpos * s + s * 0.3,
    Ypos * s + s * 0.3,
    s * 0.4,
    s * 0.4
  );*/
  }

  function drawPlayer() {
    ctx.fillStyle = "#0f0";
    const image = document.getElementById("source");
    var spd = .1;
    if(Math.abs(imgX-Xpos) >= n-1.5 || Math.abs(imgY-Ypos) >= n-1.5) {
        imgX=Xpos;
        imgY=Ypos;
    }
    else if(Math.abs(imgX-Xpos) >= 2 || Math.abs(imgY-Ypos) >= 2) {
        if(Math.abs(imgY-Ypos) > Math.abs(imgX-Xpos))
            spd = Math.abs(imgY-Ypos)/10.0;
        else
            spd = Math.abs(imgX-Xpos)/10.0;
    }
    if(imgX < Xpos-spd/2) {
        imgX += spd;
    }
    else if(imgX > Xpos + spd/2) {
        imgX -= spd;
    }
    else imgX = Xpos;
    if(imgY < Ypos - spd/2) {
        imgY += spd;
    }
    else if(imgY > Ypos + spd/2) {
        imgY -= spd;
    }
    else imgY = Ypos;
    ctx.drawImage(
      image,
      vOff + imgX * s + s * 0.3,
      imgY * s + s * 0.3,
      s * 0.4,
      s * 0.4,
    );
  }

  function drawHalo() {
    ctx.strokeStyle = "#ff8f";
    var baseStr = "#ff8";
    var hexStr = "0123456789abcdef";
    var scale = .05;
    ctx.lineWidth = s*scale;
    for(let i=0; i<16; i++) {
        ctx.strokeStyle = baseStr + hexStr.substr(15-i, 1);
        ctx.beginPath();
        ctx.arc(vOff + imgX * s + s * 0.5, imgY * s + s * 0.5, s*scale*(i+1), 0, 2 * Math.PI);
        ctx.stroke();
    }
    
  }

  function drawFog() {
    s = Math.min(W, H) / n;

    //ctx.fillStyle="rgba(0,0,0,.7)"
    ctx.fillStyle = "#000";
    ctx.fillRect(0 + vOff - 3, -2, (imgX - visibility) * (s + 1) + 3, s * n + 4);
    ctx.fillRect(0 + vOff - 3, -2, (s + 1) * n + 3, (imgY - visibility) * s + 4);
    ctx.fillRect(
      (imgX - visibility) * s + vOff - 2,
      (imgY + visibility + 1) * s-2,
      (s + 1) * (n - (imgX - visibility)) + 4,
      s * (n - (imgY + visibility)) + 4,
    );
    ctx.fillRect(
      (imgX + visibility + 1) * s + vOff -2,
      (imgY - visibility) * s -2,
      (s + 1) * (n - (imgX + visibility)) +4,
      s * (n - (imgY - visibility)) +4,
    );
    ctx.fillStyle = "rgba(0,0,0,.5)";
    ctx.globalCompositeOperation = "destination-out";

    ctx.beginPath();
    ctx.fillRect(
      (imgX - visibility) * s + vOff,
      (imgY - visibility) * s,
      (2 * visibility + 1) * s,
      (2 * visibility + 1) * s,
    );

    ctx.fill();

    ctx.globalCompositeOperation = "source-over";
  }

  function flashLights() {
    start = new Date().getTime();
  }

  /* ================= LOOP ================= */

createMaze();
var start = new Date().getTime();
function loop() {
  

  drawMaze();
  var timeDiff = (new Date().getTime() - start);
  if (timeDiff > 1500 /*&& timeDiff < 1300 || // after 1 sec light, .3 dark
     timeDiff > 1500 && timeDiff < 1700 || // then .2 light and .2 dark
     timeDiff > 1800 */){ // then .1 light and then forever dark
    drawFog();
  }
  
  requestAnimationFrame(loop);

}
loop();
</script>
