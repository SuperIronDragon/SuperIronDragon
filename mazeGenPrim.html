<!doctype html>

<script>


function createMaze() {
    
    // reset level

    Xpos = 0; // character position
    Ypos = 0;
    HmazeArray = []; // reset arrays
    VmazeArray = [];

    for (let i = 0; i < n; i++) {
      // Create an empty inner array for each row
      HmazeArray.push([]);
      for (let j = 0; j < n + 1; j++) {
        HmazeArray[i].push(1);
      }
    }

    for (let i = 0; i < n + 1; i++) {
      // Create an empty inner array for each row
      VmazeArray.push([]);
      for (let j = 0; j < n; j++) {
        VmazeArray[i].push(1);
      }
    }
    var gridArr = [];
    for (let i = 0; i < n; i++) {
      gridArr.push([]);
      for (let j = 0; j < n; j++) {
        gridArr[i].push(2);
      }
    }
    //  using Kruskalâ€™s algorithm
    var numunconnected = n*n-1;
    var frontierArr = [];
    var startCol=0;
    var startRow=0;
    // console.log(startCol + "  " + startRow);
    gridArr[startCol][startRow] = 0;
    if(startCol>0) {
      gridArr[startCol-1][startRow] = 1;
      frontierArr.push([startCol-1, startRow]);
    }
    if(startCol<n-1) {
      gridArr[startCol+1][startRow] = 1;
      frontierArr.push([startCol+1, startRow]);
    }
    if(startRow>0) {
      gridArr[startCol][startRow-1] = 1;
      frontierArr.push([startCol, startRow-1]);
    }
    if(startRow<n-1) {
      gridArr[startCol][startRow+1] = 1;
      frontierArr.push([startCol, startRow+1]);
    }

    var i=0;
    while(frontierArr.length > 0) {
      var currPos = frontierArr.splice(Math.floor(Math.random() * frontierArr.length), 1)[0];
      var validAdj = [];
      // console.log("loop iter " + i);
      i++;
      // console.log(currPos);
      gridArr[currPos[0]][currPos[1]] = 0;
      
      if(currPos[0]>0) { // w=0
        if(gridArr[currPos[0]-1][currPos[1]] == 0)
          validAdj.push([currPos[0]-1,currPos[1], 0]);
        else if(gridArr[currPos[0]-1][currPos[1]] == 2) {
          gridArr[currPos[0]-1][currPos[1]] = 1;
          frontierArr.push([currPos[0]-1, currPos[1]]);
        }
          
      }
      if(currPos[0]<n-1) { // e=1
        if(gridArr[currPos[0]+1][currPos[1]] == 0)
          validAdj.push([currPos[0]+1,currPos[1], 1]);
        else  if(gridArr[currPos[0]+1][currPos[1]] == 2){
          gridArr[currPos[0]+1][currPos[1]] = 1;
          frontierArr.push([currPos[0]+1, currPos[1]]);}
      }
      if(currPos[1]>0) { // n=2
        if(gridArr[currPos[0]][currPos[1]-1] == 0)
          validAdj.push([currPos[0],currPos[1]-1, 2]);
        else if(gridArr[currPos[0]][currPos[1]-1] == 2){
          gridArr[currPos[0]][currPos[1]-1] = 1;
          frontierArr.push([currPos[0], currPos[1]-1]);}
      }
      if(currPos[1]<n-1) { // s=3
        if(gridArr[currPos[0]][currPos[1]+1] == 0)
          validAdj.push([currPos[0],currPos[1]+1, 3]);
        else if(gridArr[currPos[0]][currPos[1]+1] == 2){
          gridArr[currPos[0]][currPos[1]+1] = 1;
          frontierArr.push([currPos[0], currPos[1]+1]);}
      }
      var newConn = validAdj.splice(Math.floor(Math.random() * validAdj.length), 1)[0];

      if(newConn[2]==0) // w
        VmazeArray[currPos[0]][currPos[1]] = 0;
      if(newConn[2]==1) // e
        VmazeArray[currPos[0]+1][currPos[1]] = 0;
      if(newConn[2]==2) // n
        HmazeArray[currPos[0]][currPos[1]] = 0;
      if(newConn[2]==3) // s
        HmazeArray[currPos[0]][currPos[1]+1] = 0;
      // console.log(frontierArr.length + "  " + newConn[2]);
    }
    

} // end of createMaze()

</script>