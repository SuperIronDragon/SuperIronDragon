<!doctype html>
<meta
  name="viewport"
  content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"
/>
<body style="margin: 0; background: #000; overflow: hidden; touch-action: none">
  <canvas id="proceduralCanvas"></canvas>
  <script>
    let c = proceduralCanvas,
      g = c.getContext("2d", { alpha: false }),
      W = 10,
      H = 20,
      t = 0,
      sc = 0,
      over = 0;
    let S = 24,
      ox = 0,
      oy = 0,
      sx = 0,
      sy = 0,
      st = 0,
      PX = 3; // PX = background noise pixel size (chunky)
    let B = new Uint8Array(W * H); // occupied
    let BS = new Uint32Array(W * H); // per-cell seed for stable noise
    let bg = document.createElement("canvas"),
      bgx = bg.getContext("2d", { alpha: false }),
      bgID,
      bgD,
      bw = 0,
      bh = 0;

    // xorshift32 PRNG (tiny, deterministic)
    let rng = 123456789;
    let R = () =>
      ((rng ^= rng << 13), (rng ^= rng >>> 17), (rng ^= rng << 5)) >>> 0;

    // --- build fixed chunky background once ---
    function buildBG() {
      bw = Math.max(1, ~~(c.width / PX));
      bh = Math.max(1, ~~(c.height / PX));
      bg.width = bw;
      bg.height = bh;
      bgID = bgx.createImageData(bw, bh);
      bgD = bgID.data;
      for (let i = 0; i < bgD.length; i += 4) {
        let v = (R() & 1) * 255; // fixed 0/255 noise, deterministic
        bgD[i] = bgD[i + 1] = bgD[i + 2] = v;
        bgD[i + 3] = 255;
      }
      bgx.putImageData(bgID, 0, 0);
    }

    // deterministic “noise fill” inside one cell using a seed (stable)
    function cellNoise(seed, px, py) {
      // Cheap pseudo-random gray from seed (no per-frame randomness)
      seed ^= seed >>> 16;
      seed = (seed * 2246822519) >>> 0;
      seed ^= seed >>> 13;
      seed = (seed * 3266489917) >>> 0;
      seed ^= seed >>> 16;
      let v = (seed & 1) * 255;
      g.fillStyle = "rgb(" + v + "," + v + "," + v + ")";
      g.fillRect(px, py, S, S);
    }

    function resize() {
      c.width = innerWidth;
      c.height = innerHeight;
      S = ~~Math.min(c.width / (W + 2), c.height / (H + 2));
      ox = ~~((c.width - W * S) / 2);
      oy = ~~((c.height - H * S) / 2);
      g.imageSmoothingEnabled = false;
      buildBG(); // rebuild fixed bg on resize
    }
    onresize = resize;
    resize();

    // tetrominoes as 4x4 bitmasks
    let T = [
      [0x0f00, 0x2222, 0x00f0, 0x4444],
      [0x8e00, 0x6440, 0x0e20, 0x44c0],
      [0x2e00, 0x4460, 0x0e80, 0xc440],
      [0x6600, 0x6600, 0x6600, 0x6600],
      [0x6c00, 0x4620, 0x06c0, 0x8c40],
      [0x4e00, 0x4640, 0x0e40, 0x4c40],
      [0xc600, 0x2640, 0x0c60, 0x4c80],
    ];
    let bag = [],
      k = 0,
      r = 0,
      px = 3,
      py = -1,
      drop = 0,
      ps = 0; // ps = active piece seed
    function nb() {
      bag = [0, 1, 2, 3, 4, 5, 6];
      for (let i = 6; i; i--) {
        let j = R() % (i + 1);
        [bag[i], bag[j]] = [bag[j], bag[i]];
      }
    }
    function bit(m, i) {
      return (m >> (15 - i)) & 1;
    }
    function hit(x, y, rr) {
      let m = T[k][rr];
      for (let i = 0; i < 16; i++)
        if (bit(m, i)) {
          let X = x + (i & 3),
            Y = y + (i >> 2);
          if (X < 0 || X >= W || Y >= H) return 1;
          if (Y >= 0 && B[Y * W + X]) return 1;
        }
      return 0;
    }
    function spawn() {
      if (!bag.length) nb();
      k = bag.pop();
      r = 0;
      px = 3;
      py = -1;
      drop = 0;
      ps = R(); // fixed seed for this falling piece
      if (hit(px, py, r)) over = 1;
    }
    function clear() {
      let lines = 0;
      for (let y = 0; y < H; y++) {
        let full = 1;
        for (let x = 0; x < W; x++)
          if (!B[y * W + x]) {
            full = 0;
            break;
          }
        if (full) {
          lines++;
          for (let yy = y; yy > 0; yy--)
            for (let x = 0; x < W; x++) {
              B[yy * W + x] = B[(yy - 1) * W + x];
              BS[yy * W + x] = BS[(yy - 1) * W + x];
            }
          for (let x = 0; x < W; x++) {
            B[x] = 0;
            BS[x] = 0;
          }
        }
      }
      if (lines) sc += [0, 100, 300, 500, 800][lines];
    }
    function lock() {
      let m = T[k][r];
      for (let i = 0; i < 16; i++)
        if (bit(m, i)) {
          let X = px + (i & 3),
            Y = py + (i >> 2);
          if (Y >= 0) {
            let idx = Y * W + X;
            B[idx] = 1;
            // fixed seed per locked cell (derived from piece seed + local cell)
            BS[idx] = ps ^ ((i * 2654435761) >>> 0);
          }
        }
      clear();
      spawn();
    }
    function mv(dx) {
      if (!hit(px + dx, py, r)) px += dx;
    }
    function rt() {
      let rr = (r + 1) & 3;
      if (!hit(px, py, rr)) r = rr;
      else if (!hit(px - 1, py, rr)) (px--, (r = rr));
      else if (!hit(px + 1, py, rr)) (px++, (r = rr));
    }
    function dn() {
      if (!hit(px, py + 1, r)) py++;
      else lock();
    }
    function hard() {
      while (!hit(px, py + 1, r)) py++;
      lock();
    }

    function draw() {
      // fixed background noise
      g.drawImage(bg, 0, 0, c.width, c.height);

      // locked blocks (fixed seeds)
      for (let y = 0; y < H; y++)
        for (let x = 0; x < W; x++) {
          let idx = y * W + x;
          if (B[idx]) cellNoise(BS[idx], ox + x * S, oy + y * S);
        }

      // active piece (fixed seed, fixed per-cell derivation)
      if (!over) {
        let m = T[k][r];
        for (let i = 0; i < 16; i++)
          if (bit(m, i)) {
            let X = px + (i & 3),
              Y = py + (i >> 2);
            if (Y >= 0)
              cellNoise(ps ^ ((i * 1597334677) >>> 0), ox + X * S, oy + Y * S);
          }
      }

      // HUD
      g.fillStyle = "rgba(255,255,255,.7)";
      g.font = ~~(S * 0.8) + "px system-ui, sans-serif";
      g.fillText("SCORE " + sc, 10, ~~(S * 1.2));

      if (over) {
        g.fillStyle = "rgba(0,0,0,.55)";
        g.fillRect(0, 0, c.width, c.height);
        g.fillStyle = "#fff";
        g.textAlign = "center";
        g.fillText("GAME OVER", c.width / 2, c.height / 2);
        g.fillText("TAP TO RESTART", c.width / 2, c.height / 2 + S);
        g.textAlign = "left";
      }
    }

    function step() {
      t++;
      if (!over) {
        drop++;
        let sp = Math.max(6, 30 - ~~(sc / 400));
        if (drop >= sp) {
          drop = 0;
          dn();
        }
      }
      draw();
      requestAnimationFrame(step);
    }

    function restart() {
      B.fill(0);
      BS.fill(0);
      sc = 0;
      over = 0;
      rng = 123456789; // reset rng for reproducible look (optional)
      buildBG();
      nb();
      spawn();
    }

    // touch controls
    addEventListener("pointerdown", (e) => {
      sx = e.clientX;
      sy = e.clientY;
      st = performance.now();
    });
    addEventListener(
      "pointerup",
      (e) => {
        if (over) {
          restart();
          return;
        }
        let dx = e.clientX - sx,
          dy = e.clientY - sy,
          dt = performance.now() - st;
        if (Math.abs(dy) > Math.abs(dx) && dy > 20) {
          if (dy > 80 && dt < 200) hard();
          else dn();
        } else {
          if (e.clientY < innerHeight * 0.25) rt();
          else e.clientX < innerWidth / 2 ? mv(-1) : mv(1);
        }
      },
      { passive: true },
    );

    restart();
    step();
  </script>
</body>
